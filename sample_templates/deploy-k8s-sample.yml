name: Deployment-sample

on:
  workflow_dispatch:
    inputs:
      github_general:
        default: 'PLACE_HOLDER_GITHUB_GENERAL'
        type: string
        required: true
      github_kubernetes:
        default: 'PLACE_HOLDER_GITHUB_KUBERNETES'
        type: string
        required: false

jobs:
  deploy:
    runs-on: [self-hosted]
    environment:
      name: 'ENV'
      
    steps:
      # Printing Input Variables for Debugging.
      - name: Print input variables
        run: |
          echo 'github_general: ${{ github.event.inputs.github_general }}'
          echo 'github_kubernetes: ${{ github.event.inputs.github_kubernetes }}'
          
      - name: Checkout Code
        uses: actions/checkout@v2
 
      - name: create-json for metadata for github_general
        id: create-json-general
        uses: jsdaniell/create-json@1.1.2
        with:
          name: "github_general.json"
          json: ${{ github.event.inputs.github_general }}

      - name: create-json for metadata for github_kubernetes
        id: create-json-kube
        uses: jsdaniell/create-json@1.1.2
        with:
          name: "github_kubernetes.json"
          json: ${{ github.event.inputs.github_kubernetes }}
          

      - name: creating environment variables for github
        run: |
          echo "repo_name=$(cat github_general.json | jq -r '.repoName')" >> $GITHUB_ENV
          echo "helm_release_name=$(cat github_general.json | jq -r '.helmReleaseName')" >> $GITHUB_ENV
          echo "namespace=$(cat github_kubernetes.json | jq -r '.namespace')" >> $GITHUB_ENV
          echo "repository_url=$(cat github_general.json | jq -r '.repositoryUrl')" >> $GITHUB_ENV
          echo "build_number=$(cat github_general.json | jq -r '.latestBuildNumber')" >> $GITHUB_ENV
          echo "artifactory_username=$(cat github_general.json | jq -r '.artifactoryUsernameCredentialId')" >> $GITHUB_ENV
          echo "artifactory_password=$(cat github_general.json | jq -r '.artifactoryPasswordCredentialId')" >> $GITHUB_ENV


      - name: use jemson
        run: |
          echo ${{ env.repo_name }} 
          echo ${{ env.helm_release_name }} 
          echo ${{ env.namespace }}
          echo ${{ env.repository_url }}
          echo ${{ env.build_number }}
          echo ${{ env.artifactory_username }}
          echo ${{ env.artifactory_password }}


      - id: project_name
        uses: ASzc/change-string-case-action@v2
        with:
          string: ${{ env.repo_name }} 

      - name: Create values.yml file from json data 
        uses: fabasoad/yaml-json-xml-converter-action@v1.0.0
        id: json2yaml
        with:
          path: 'github_kubernetes.json'
          from: 'json'
          to: 'yaml'

      - name: Print json2yaml result
        run: |
          echo "${{ steps.json2yaml.outputs.data }}" > Helm.yaml
          ls -lart
          
      - run: |    
          cat Helm.yaml

      #configure kubeconfig
      - name: Configure Kubeconfig File
        env:
          KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}
        run: |
           mkdir -p $PWD/.kube
           echo "${{ env.KUBE_CONFIG }}" | base64 -d > $PWD/.kube/config

# Install Kubectl
      - name: Install kubectl version
        env:
          KUBECTL_VERSION: "1.23.5-00"
        run: |
          sudo apt-get update
          sudo apt-get install -y apt-transport-https ca-certificates curl
          sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
          echo "deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list
          sudo apt-get update
          sudo apt-get install -y kubectl=${{ env.KUBECTL_VERSION }} jq
          #kubectl version

  #Install Helm
      - name: Install helm
        env:
          HELM_VERSION: 3.8.0
        run: |
          curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
          chmod 700 get_helm.sh
          ./get_helm.sh -v v${{ env.HELM_VERSION }}
          helm version


          

## Check the Namespace if null or default then create namespace depending upon the github repository.
#      - name: Determine Kubernetes Namespace
#        run: |
#          NAMESPACE="$($GITHUB_REPOSITORY | sed 's/\//_/g' )"
#          echo $NAMESPACE
#          echo REPO_NAME=$GITHUB_REPOSITORY | sed 's/\//_/g' >> $GITHUB_ENV
#          if [ "${{ github.event.inputs.k8s_namespace }}" == "default"  || "${{ github.event.inputs.k8s_namespace }}" == "" ]
#          then
#            NAMESPACE=$GITHUB_ACTION_REPOSITORY | sed 's/\//_/g'
#          else
#            NAMESPACE="${{ github.event.inputs.k8s_namespace }}"
#          fi
#          echo $NAMESPACE
#          echo "NAMESPACE=$NAMESPACE" >> $GITHUB_ENV
#
#

# Create namespace
      - name: Create Namespace if not present
        run: |
          KUBECONFIG=$(echo $PWD/.kube/config)
          kubectl create namespace ${NAMESPACE} || true
        env:
         NAMESPACE: ${{ env.namespace }}
         KUBECONFIG: '$PWD/.kube/config'


# Configure Docker Regsitry Credentials
      - name: Configure Docker Registry Credentials
        run: |
          KUBECONFIG=$(echo $PWD/.kube/config)
          kubectl -n ${{ env.namespace }} create secret docker-registry regcred \
            --docker-server="${{ env.repository_url }}" \
            --docker-username="${{ secrets[env.artifactory_username] }}"\
            --docker-password='${{ secrets[env.artifactory_password] }}' || true
        env:
         KUBECONFIG: '$PWD/.kube/config'
 



# task to install kubernetes helm repo
      - name: Install Helm Release
        run: |
          KUBECONFIG=$(echo $PWD/.kube/config)
          pwd
          ls -lart
          sed -i s+#SERVICE_NAME#+"${RELEASE_NAME}"+g ./helm_chart/values.yaml ./helm_chart/Chart.yaml
          kubectl create ns ${NAMESPACE} || true
          helm upgrade --install ${RELEASE_NAME} -n ${NAMESPACE} helm_chart --atomic --timeout 300s --set image.repository=${REPOSITORY_URL}/${IMAGE_NAME} --set image.tag=${BUILD_NUMBER} --set image.registrySecret="regcred"  --set service.internalport="8080" -f Helm.yaml
          sleep 10
          kubectl rollout restart deploy "${RELEASE_NAME}" -n ${NAMESPACE}
        env:
         IMAGE_NAME: ${{ steps.project_name.outputs.lowercase }}
         RELEASE_NAME: ${{ env.helm_release_name}}
         NAMESPACE: ${{ env.namespace }}
         REPOSITORY_URL: ${{ env.repository_url }}
         BUILD_NUMBER: ${{ env.build_number }}
         SERVICE_PORT: "8080"
         KUBECONFIG: '$PWD/.kube/config'


# task for getting the URL
      - name: Getting Live URL
        run: |
          KUBECONFIG=$(echo $PWD/.kube/config)
          release_name=${RELEASE_NAME}
          service_name="${RELEASE_NAME}"
          temp_service_name=$release_name
          URL=$(kubectl get svc -n ${NAMESPACE} | grep $temp_service_name | awk '{print $4}')
          echo $URL
          if [ url != "<pending>" ] 
          then
                    echo "##\$@\$ http://$URL ##\$@\$"
          else
                    echo "access url has not generated"
          fi
        env:
         IMAGE_NAME: ${{ steps.project_name.outputs.lowercase }}
         RELEASE_NAME: ${{ env.helm_release_name}}
         NAMESPACE: ${{ env.namespace }}
         REPOSITORY_URL: ${{ env.repository_url }}
         BUILD_NUMBER: ${{ env.build_number }}
         SERVICE_PORT: "8080"
         KUBECONFIG: '$PWD/.kube/config'
          

#      - uses: actions-hub/kubectl@master
#        name: Create Namespace
#        env:
#          KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}
#        with:
#          args: create namespace ${{ github.event.inputs.k8s_namespace }} || true

# Create Docker Registry Credentials

# study what needs to be installed
# steps
# check for promote
#
# create namespace - Done
# docker registry credentials Done
#
#         sed -i s+#SERVICE_NAME#+"$service"+g ./helm_chart/values.yaml ./helm_chart/Chart.yaml
#         kubectl create ns "$namespace_name" || true
#         helm upgrade --install "${generalPresent.repoName}" -n "$namespace_name" helm_chart --atomic --timeout 300s --set image.repository="$REGISTRY_URL" --set image.tag="$BUILD_TAG" --set image.registrySecret="regcred"  --set service.internalport="$SERVICE_PORT" -f Helm.yaml
#         sleep 10
#         kubectl rollout restart deploy "${generalPresent.repoName}-$service" -n "$namespace_name"
# The below is for live URL
#          env.temp_service_name = "$RELEASE_NAME-$service".take(63)
#          def url = sh (returnStdout: true, script: '''kubectl get svc -n "$namespace_name" | grep "$temp_service_name" | awk '{print $4}' ''').trim()
#          if (url != "<pending>") {
#          print("##\$@\$ http://$url ##\$@\$")
#          } else {
#          currentBuild.result = 'ABORTED'
#          error('Aborting the job as access url has not generated')
#          }
#          }
