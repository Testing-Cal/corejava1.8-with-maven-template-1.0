name: Deployment-sample
on:
  workflow_dispatch:
    inputs:
      github_general:
        type: string
        default: 'PLACE_HOLDER_GITHUB_GENERAL'
        required: true
      github_docker:
        type: string
        default: 'PLACE_HOLDER_GITHUB_DOCKER'
        required: true



jobs:
  deploy:
    runs-on: [self-hosted]
    environment:
      name: 'ENV'
      url: 'https://calibo.com'

    steps:
      - name: Print input variables
        run: | 
          echo "github_general: ${{ github.event.inputs.github_general }}"
          echo "github_docker: ${{ github.event.inputs.github_docker }}"
          
         # creating json file
      - name: create-json for metadata github_general
        id: create-json-general
        uses: jsdaniell/create-json@1.1.2
        with:
         name: "github_general.json"
         json: ${{ github.event.inputs.github_general }}

      - name: create-json for metadata github_docker
        id: create-json-docker
        uses: jsdaniell/create-json@1.1.2
        with:
         name: "github_docker.json"
         json: ${{ github.event.inputs.github_docker }}
 
      - name: create environment variable
        run: |
          echo "repo_name=$(cat github_general.json | jq -r '.repoName')" >> $GITHUB_ENV
          echo "artifactory_type=$(cat github_general.json | jq -r '.artifactory')" >> $GITHUB_ENV
          echo "docker_host_ip=$(cat github_docker.json | jq -r '.dockerHostIp')" >> $GITHUB_ENV
          echo "artifactory_username=$(cat github_general.json | jq -r '.artifactoryUsernameCredentialId')" >> $GITHUB_ENV
          echo "artifactory_password=$(cat github_general.json | jq -r '.artifactoryPasswordCredentialId')" >> $GITHUB_ENV
          echo "repository_url=$(cat github_general.json | jq -r '.repositoryUrl')" >> $GITHUB_ENV
          echo "build_number=$(cat github_general.json | jq -r '.latestBuildNumber')" >> $GITHUB_ENV
          echo "app_port=$(cat github_docker.json | jq -r '.appPort')" >> $GITHUB_ENV
          echo "host_port=$(cat github_docker.json | jq -r '.hostPort')" >> $GITHUB_ENV
          #echo "ssh_key=$(cat github_docker.json | jq -r '.ssh_key')" >> $GITHUB_ENV
          
      - name: print variables
        run: |
          echo ${{ env.repo_name }}
          echo ${{ env.artifactory_type }}
          echo ${{ env.docker_host_ip }}
          echo ${{ env.repository_url }}
          echo ${{ env.build_number }}
          echo ${{ env.app_port }}
          echo ${{ env.host_port }}
         

      - name: Assign variable Repository type
        id: registry_type
        run: echo '::set-output name=secret::${{ env.artifactory_type }}'

    # Since we need docker image name in lower case, using this funciton.
      - id: project_name
        uses: ASzc/change-string-case-action@v2
        with:
          string: ${{ env.repo_name }} 

      - name: Deploy to EC2
        if: steps.registry_type.outputs.secret == 'AWS'
        env:
          # ssh key must be copied by user to runner.
          #PRIVATE_KEY: ${{ env.ssh_key  }} 
          HOSTNAME: ${{ env.docker_host_ip  }}
          USER_NAME: "ec2-user"#"ci-user"
          ARTIFACTORY_USERNAME: ${{ secrets[env.artifactory_username] }}
          ARTIFACTORY_PASSWORD: ${{ secrets[env.artifactory_password] }}
          REGISTRY_URL : ${{ env.repository_url }}
          ECR_REGION: 'us-east-1'
          IMAGE_NAME: ${{ steps.project_name.outputs.lowercase }}

        run: |
          #since key is already present so no need to run this ::::: echo "$PRIVATE_KEY" > private_key && chmod 600 private_key
          ssh -o StrictHostKeyChecking=no -i /home/ubuntu/.ssh/codeserver ${USER_NAME}@${HOSTNAME} '

            #Now we have got the access of EC2 and we will start the deploy .
            # export access key and
            export AWS_ACCESS_KEY_ID=${ARTIFACTORY_USERNAME}
            export AWS_SECRET_ACCESS_KEY=${ARTIFACTORY_PASSWORD}
            echo "Considering that we have AWS CLI already present ${ECR_REGION}"
            echo "${{ env.ECR_REGION }}"
            aws --version 
            docker stop ${{ env.IMAGE_NAME }} || true && docker rm ${{ env.IMAGE_NAME }} || true
            docker login -u AWS -p $(aws ecr get-login-password --region ${{ env.ECR_REGION }}) ${{ env.REGISTRY_URL }}
            docker run -d -p ${{ env.host_port }}:${{ env.app_port }} --name=${{ env.IMAGE_NAME }} ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ env.build_number }}
            docker ps
          '

      - name: Deploy to Azure VM
        if: steps.registry_type.outputs.secret == 'Azure' || steps.registry_type.outputs.secret == 'JFROG'
        env:
          #PRIVATE_KEY: ${{ env.ssh_key  }}
          HOSTNAME: ${{ env.docker_host_ip  }}
          USER_NAME: "azureuser" # ci-user
          ARTIFACTORY_USERNAME: ${{ secrets[env.artifactory_username] }}
          ARTIFACTORY_PASSWORD: ${{ secrets[env.artifactory_password] }}
          REGISTRY_URL: ${{ env.repository_url }}
          IMAGE_NAME: ${{ steps.project_name.outputs.lowercase }}

        run: |
          #echo "$PRIVATE_KEY" > private_key && chmod 600 private_key
          ssh -o StrictHostKeyChecking=no -i /home/ubuntu/.ssh/azure-github.pem ${USER_NAME}@${HOSTNAME} '

            # Considering that we have AWS CLI already present
            echo ${{ env.ARTIFACTORY_PASSWORD }} | docker login -u lazsa --password-stdin ${{ env.REGISTRY_URL }}
            docker version
            docker stop ${{ env.IMAGE_NAME }} || true && docker rm ${{ env.IMAGE_NAME }} || true
            docker run -d -p ${{ env.host_port }}:${{ env.app_port }} --name=${{ env.IMAGE_NAME }} ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ env.build_number }}
            docker ps
          '
